import pickle
import numpy as np
import pandas as pd
import re
from nltk.corpus import stopwords
from nltk.stem.porter import PorterStemmer
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
import nltk
import os
import ssl

print("running")
# try:
#     _create_unverified_https_context = ssl._create_unverified_context
# except AttributeError:
#     pass
# else:
#     ssl._create_default_https_context = _create_unverified_https_context

# nltk.download('stopwords')

# Load the model and vectorizer
model_path = "./improved_trained_model.sav"
with open(model_path, 'rb') as file:
    vectorizer, loaded_model_v2 = pickle.load(file)

# Path to the dataset CSV file
dataset_csv_path = "./Apple.csv"

# Check if the file exists and is accessible
if not os.path.isfile(dataset_csv_path):
    raise FileNotFoundError(f"The dataset file {dataset_csv_path} does not exist.")

try:
    # Read the CSV file directly
    brand_tweets_df = pd.read_csv(dataset_csv_path)
except PermissionError:
    raise PermissionError(f"Permission denied: Unable to access the file {dataset_csv_path}. Please check the file permissions.")
except Exception as e:
    raise Exception(f"An error occurred while reading the CSV file: {e}")

# Check for and drop any null values
if brand_tweets_df.isnull().values.any():
    brand_tweets_df = brand_tweets_df.dropna()

def analyze_brand_tweets():
    # Ensure 'text' column exists (adjust if column name is different)
    if 'text' not in brand_tweets_df.columns:
        print("Error: 'text' column not found in the CSV file. Please ensure your CSV has a 'text' column.")
        return

    # Preprocess the text data (using the same stemming function as in your original training)
    port_stem_new = PorterStemmer()

    def stemming(content):
        stemmed_content = re.sub('[^a-zA-Z]', ' ', content)
        stemmed_content = stemmed_content.lower()
        stemmed_content = stemmed_content.split()
        stemmed_content = [port_stem_new.stem(word) for word in stemmed_content if
                           not word in stopwords.words('english')]
        stemmed_content = ' '.join(stemmed_content)
        return stemmed_content

    brand_tweets_df['stemmed_content'] = brand_tweets_df['text'].apply(stemming)

    # Vectorize the tweets using the same vectorizer used during training
    X_brand_tweets = vectorizer.transform(brand_tweets_df['stemmed_content'].values)

    # Predict sentiments for brand tweets
    predictions = loaded_model_v2.predict(X_brand_tweets)
    brand_tweets_df['sentiment'] = predictions
    print(predictions)

    # Analyze the distribution of sentiments
    sentiment_counts = pd.Series(predictions).value_counts(normalize=True) * 100
    print(sentiment_counts)

    Brand_Name = input("Enter the Brand Name: ")

    print(f"Sentiment Distribution for {Brand_Name}:")
    print(f"Positive: {sentiment_counts.get(1, 0):.2f}%")
    print(f"Negative: {sentiment_counts.get(0, 0):.2f}%")
    print(f"Neutral: {sentiment_counts.get(2, 0):.2f}%")

analyze_brand_tweets()

print_some_negative_tweets = input("Do you want to print some negative tweets? (yes/no): ").lower()
if print_some_negative_tweets == 'yes':
    print("Some Negative Tweets:")
    negative_tweets = brand_tweets_df[brand_tweets_df['sentiment'] == 0].head()
    for tweet in negative_tweets['text']:
        print(tweet)
else:
    print("Skipping printing some negative tweets.")

print_some_positive_tweets = input("Do you want to print some positive tweets? (yes/no): ").lower()
if print_some_positive_tweets == 'yes':
    print("Some Positive Tweets:")
    positive_tweets = brand_tweets_df[brand_tweets_df['sentiment'] == 1].head()
    for tweet in positive_tweets['text']:
        print(tweet)
else:
    print("Skipping printing some positive tweets.")

print_some_neutral_tweets = input("Do you want to print some neutral tweets? (yes/no): ").lower()
if print_some_neutral_tweets == 'yes':
    print("Some Neutral Tweets:")
    neutral_tweets = brand_tweets_df[brand_tweets_df['sentiment'] == 2].head()
    for tweet in neutral_tweets['text']:
        print(tweet)
else:
    print("Skipping printing some neutral tweets.")

